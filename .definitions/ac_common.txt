ac.debug(key: string, value: string = nullptr)
ac.setLogSilent(value: boolean = true)
ac.log(value: string)
ac.warn(value: string)
ac.error(value: string)
ac.perfBegin(value: string)
ac.perfEnd(value: string)
ac.perfFrameBegin(value: integer)
ac.perfFrameEnd(value: integer)
ac.dirname(): string
ac.findFile(fileName: string): string
ac.getPatchVersion(): string
ac.getPatchVersionCode(): integer // Increments with every CSP build
ac.getFolder(folderID: ac.FolderID): string
ac.getTrackId(): string
ac.getTrackID(): string
ac.getTrackLayout(): string
ac.getTrackFullID(separator: string = "-"): string
ac.getTrackName(): string
ac.getCameraPosition(): vec3
ac.getCameraUp(): vec3
ac.getCameraSide(): vec3
ac.getCameraForward(): vec3
ac.getCameraDirection(): vec3
ac.getCameraFOV(): number // Value in degrees
ac.getCameraPositionTo(r: vec3)
ac.getCameraUpTo(r: vec3)
ac.getCameraSideTo(r: vec3)
ac.getCameraForwardTo(r: vec3)
ac.getCameraDirectionTo(r: vec3)
ac.getCameraPositionRelativeToCar(): vec3
ac.getCompassAngle(dir: vec3): number // Angle from 0 to 360 (0/360 for north, 90 for east, etc.)
ac.getSunAngle(): number // Value in degrees
ac.getSunPitchAngle(): number // Value in degrees
ac.getSunHeadingAngle(): number // Value in degrees
ac.isInteriorView(): boolean // Returns true if camera is focused on interior (interior audio is playing)
ac.isInReplayMode(): boolean
ac.setTextureKey(key: string = nullptr)
ac.encodeTexture(filename: string, outputFilename: string, key: string, applyLz4Compression: boolean)
ac.compressTexture(filename: string, outputFilename: string)
ac.getSoundSpeedMs(): number
ac.getLastError(): string
ac.lapTimeToString(time: number, allowHours: boolean = false): string
ac.getCountryName(nationCode: string): string
ac.getAudioVolume(audioChannelKey: string): number // value from 0 to 1
ac.getCarSpeedKmh(carIndex: integer): number
ac.getGroundYApproximation(): number
ac.getDeltaT(): number // seconds
ac.getGameDeltaT(): number // seconds
ac.getScriptDeltaT(): number
ac.getConditionsTimeScale(): number
ac.getPpFilter(): string
ac.getWindVelocity(): vec3 // Value is in m/s
ac.getWindVelocityTo(r: vec3) // Value is in m/s
ac.readDataFile(value: string): string // Can be used to access files in data.acd and, for example, read car specs
ac.parseINIppFile(iniData: string): string
ac.loadINIppFile(iniFilename: string, includeDirs: string = nullptr): string
ac.isWeatherFxActive(): boolean
ac.getTrackCoordinatesDeg(): vec2 // X for lattitude, Y for longitude
ac.getTrackTimezoneBaseDst(): vec2 // X for base offset, Y for summer time offset
ac.getMGUKDeliveryName(carIndex: integer, programIndex: integer = -1): string
ac.getTrackSectorName(trackProgress: number): string
ac.getTrackUpcomingTurn(carIndex: integer = 0): vec2
ac.getTyresName(carIndex: integer, compoundIndex: integer = -1): string
ac.getTyresIndex(carIndex: integer, tyresShortName: string): integer
ac.getTyresLongName(carIndex: integer, compoundIndex: integer = -1): string
ac.getCarID(carIndex: integer): string
ac.getCarName(carIndex: integer, includeYearPostfix: boolean = false): string
ac.getCarSkinID(carIndex: integer): string
ac.getCarBrand(carIndex: integer): string
ac.getCarCountry(carIndex: integer): string
ac.getDriverName(carIndex: integer): string
ac.getDriverNationCode(carIndex: integer): string
ac.getDriverNationality(carIndex: integer): string
ac.getDriverTeam(carIndex: integer): string
ac.getDriverNumber(carIndex: integer): integer
ac.getSessionName(sessionIndex: integer): string
ac.isKeyDown(keyIndex: ac.KeyIndex): boolean
ac.getControllerSteerValue(): number
ac.isControllerGasPressed(): boolean
ac.isControllerGearUpPressed(): boolean
ac.isControllerGearDownPressed(): boolean
ac.getSessionSpawnSet(sessionIndex: integer): string
ac.forceVisibleHeadNodes(carIndex: integer, force: boolean = true)
ac.hasTrackSpline(): boolean // Refers to AI spline.
ac.worldCoordinateToTrackProgress(v: vec3): number
ac.getTrackAISplineSides(v: number): vec2 // X for left side, Y for right side.
ac.trackProgressToWorldCoordinate(v: number): vec3
ac.trackProgressToWorldCoordinateTo(v: number, r: vec3)
ac.worldCoordinateToTrack(v: vec3): vec3
ac.trackCoordinateToWorld(v: vec3): vec3
ac.isVisibleInMainCamera(pos: vec3, radius: number): boolean // Checks visibility with frustum culling
ac.setSystemMessage(msg: string, description: string)
ac.isGamepadButtonPressed(gamepadIndex: integer, gamepadButtonID: integer): boolean
ac.getGamepadAxisValue(gamepadIndex: integer, gamepadAxisID: integer): number
ac.getJoystickCount(): integer
ac.getJoystickName(joystick: integer): string
ac.getJoystickAxisCount(joystick: integer): integer
ac.getJoystickButtonsCount(joystick: integer): integer
ac.getJoystickDpadsCount(joystick: integer): integer
ac.isJoystickButtonPressed(joystick: integer, button: integer): boolean
ac.getJoystickAxisValue(joystick: integer, axis: integer): number
ac.isJoystickAxisValue(joystick: integer, axis: integer): number
ac.getJoystickDpadValue(joystick: integer, dpad: integer): integer
ac.isJoystickDpadValue(joystick: integer, dpad: integer): integer
ac.getPenPressure(): number // Pen pressure from 0 to 1 (if mouse is used, pressure is 1)
ac.setClipboadText(text: string)
ac.getTrackDataFilename(name: string): string
ac.getCarLeaderboardPosition(carIndex: integer): integer // Returns -1 if couldn’t calculate the value.
ac.getCarRealTimeLeaderboardPosition(carIndex: integer): integer // Returns -1 if couldn’t calculate the value.
ac.console(message: string, withoutPrefix: boolean = false)
ac.setMessage(title: string, description: string)
ac.getMoonFraction(): number
ac.getAltitude(): number
ac.getSkyFeatureDirection(skyFeature: ac.SkyFeature, distance: refnumber = nullptr): vec3
ac.getSkyStarDirection(declRad: number, rightAscRad: number): vec3
ac.getServerName(): string
ac.getServerIP(): string
ac.getServerPortHTTP(): integer
ac.getServerPortTCP(): integer
ac.getServerPortUDP(): integer
ac.isTaggedAsFriend(username: string): boolean
ac.tagAsFriend(username: string, isFriend: boolean = true)
ac.updateDriverModel(carIndex: integer = -1)
ac.encodeHalf(v: number): integer
ac.encodeHalf2(v: vec2): integer
ac.decodeHalf(v: integer): number
ac.decodeHalf2(v: integer): vec2
ac.onCarJumped(carIndex: integer, callback: integer): lua_linked_id
ac.onClientConnected(callback: integer): lua_linked_id
ac.onClientDisconnected(callback: integer): lua_linked_id
ac.onFolderChanged(folder: string, filter: string, recursive: boolean, callback: integer): lua_linked_id
ac.onCSPConfigChanged(cspModuleID: string, callback: integer): lua_linked_id
ac.onScreenshot(callback: integer): lua_linked_id
ac.checksumSHA256(data: string): string
ac.checksumXXH(data: string): integer
ac.uniqueMachineKey(): string
ac.compress(data: string, type: ac.CompressionType, level: integer = 9): string
ac.decompress(data: string): string
ac.encodeBase64(data: string, trimResult: boolean = false): string
ac.decodeBase64(data: string): string
ac.utf8To16(data: string): string
ac.utf16To8(data: string): string
ac.broadcastSharedEvent(key: string, data: string): integer // Returns number of listeners to the event with given key.
ac.onSharedEvent(key: string, callback: integer): lua_linked_id
ac.setVRHandBusy(hand: integer, busy: boolean)
ac.setVRHandVibration(hand: integer, frequency: number, amplitude: number, duration: number = 0.01)
ac.getGapBetweenCars(carMainIndex: integer, carComparingToIndex: integer): number
io.getAttributes(filename: string): lua_file_attributes
io.loadAsync(filename: string, callback: integer)
io.save(filename: string, data: string): boolean
io.saveAsync(filename: string, data: string, callback: integer)
io.exists(filename: string): boolean
io.dirExists(filename: string): boolean
io.fileExists(filename: string): boolean
io.fileSize(filename: string): integer
io.creationTime(filename: string): integer
io.lastAccessTime(filename: string): integer
io.lastWriteTime(filename: string): integer
io.createDir(filename: string): boolean
io.isFileNameAcceptable(fileName: string): boolean
io.isFilePathAcceptable(filename: string): boolean
io.move(existingFilename: string, newFilename: string): boolean
io.copyFile(existingFilename: string, newFilename: string, failIfExists: boolean = true): boolean
io.deleteFile(filename: string): boolean
io.deleteDir(filename: string): boolean
io.recycle(filename: string): boolean
io.loadFromZip(zipFilename: string, entryFilename: string): string
io.checksumSHA256(filename: string, callback: integer)
os.dateGlobal(format: string, timestamp: integer): string
os.addDLLDirectory(filename: string)
os.showMessage(msg: string, type: integer = 0): integer
os.showInExplorer(filename: string)
os.openInExplorer(directory: string)
os.findAssociatedExecutable(filename: string): string
os.openTextFile(filename: string, line: integer)
os.openURL(url: string)
ac.onAlbumCoverUpdate(callback: integer): lua_linked_id
ac.mediaCurrentPeak(): vec2
ac.mediaNextTrack()
ac.mediaPreviousTrack()
ac.mediaPlayPause()
ac.getTrackDateTime(): number
ac.getSimState(): ac.StateSim
ac.getUiState(): ac.StateUi
ac.getCarState(index: integer): ac.StateCar
ac.getSim(): ac.StateSim
ac.getSession(index: integer): ac.StateSession
ac.getUI(): ac.StateUi
ac.getCar(index: integer): ac.StateCar
ac.getVR(): ac.StateVr
ac.getCarPhysics(index: integer): ac.StateCarPhysics
ac.getDualSense(gamepadIndex: integer): ac.StateDualsense
ac.setDualSense(gamepadIndex: integer, priority: number = 0, holdFor: number = 0.5): ac.StateDualsenseOutput // Returns `nil` if there is no applicable controller, make sure to check for it
web.loadRemoteModel(url: string, callback: integer)
web.loadRemoteAnimation(url: string, callback: integer)
web.loadRemoteAssets(url: string, callback: integer)
web.encryptKey(key: string): string

struct ac.StateWheel {
	const float tyreRadius; // Tyre radius in meters
	const float tyreWidth; // Tyre width in meters
	const float rimRadius; // Rim radius in meters (older cars might not have it)
	const float tyreDirty; // Dirt levels for tyres, four values, from 0 to 1
	const float tyreWear; // Tyre wear, from 0 to 1
	const float tyreVirtualKM; // Driven distance for each tyre in km (resets when tyres change, not an actual distance, rate of change depends on wear multiplier)
	const float tyreGrain;
	const float tyreBlister;
	const float tyreFlatSpot;
	const float tyreStaticPressure; // Static tyre pressure
	const float tyrePressure; // Dynamic tyre pressure
	const float temperatureMultiplier;
	const vec3 tyreTemperatureIMO; // @hidden
	const float tyreTemperature; // @hidden
	const float tyreCoreTemperature; // Core tyre temperature, in °C
	const float tyreInsideTemperature; // Inside tyre temperature, in °C
	const float tyreMiddleTemperature; // Middle tyre temperature, in °C
	const float tyreOutsideTemperature; // Outside tyre temperature, in °C
	const float tyreOptimumTemperature; // Optimum tyre temperature, in °C
	const float brakeTorque; // @hidden
	const float discTemperature;
	const float angularSpeed;
	const float slip;
	const float slipAngle; // Angle between the desired direction and the actual direction of the vehicle, in degrees
	const float slipRatio;
	const float ndSlip;
	const float load; // Tyre load in N (warning: does not have correct values for remote cars online or in replays, use `.loadK` if you want a rough but stable estimation instead)
	const float loadK; // Rough estimation of tyre load which works stable for remote cars or in replays, goes from 0 (no load) to 1 (full load)
	const float camber; // Camber angle in degrees
	const float toeIn; // Toe angle in degrees
	const float suspensionDamage;
	const float suspensionTravel;
	const float tyreLoadedRadius;
	const float waterThickness; // Water thickness in meters
	const float dz; // @hidden
	const float dy;
	const float mz; // Self aligning torque
	const vec3 contactNormal; // Normal of a contact point surface
	const vec3 contactPoint; // Contact point position in world coordinates
	const vec3 pos; // @hidden
	const vec3 position; // Wheel position in world coordinates
	const vec3 look; // Wheel heading vector
	const vec3 up; // Wheel vector directed upwards
	const vec3 outside; // Points outside of car (to the left of tyre for left tyres, to the right for right)
	const vec3 velocity;
	const mat4x4 transform; // Wheel transformation
	const float surfaceDirt; // Dirt additive coefficient of the surface below the wheel
	const int surfaceSectorID; // Sector ID of the surface below the wheel
	const float surfaceGrip; // Grip of the surface below the wheel
	const float surfaceDamping; // Damping of the surface below the wheel
	const float surfaceGranularity; // Damping of the surface below the wheel
	const float surfaceVibrationGain; // Vibration gain of the surface below the wheel
	const float surfaceVibrationLength; // Vibration length of the surface below the wheel
	const bool surfacePitlane; // If surface below the wheel is in pitlane
	const bool surfaceValidTrack; // If surface below the wheel is valid track
	const bool isBlown;
	const bool isHot;
	const uint8_t surfaceType;
}

struct ac.StateCar {
	const float mass; // Car mass in kg
	const float steerLock; // Maximum steering wheel angle in degrees
	const float maxFuel; // Maximum amount of fuel in liters
	const float exposureOutside; // Outboard exposure from car.ini
	const float exposureInside; // Onboard exposure from car.ini
	const float shakeMultiplier; // SHAKE_MUL value from car.ini
	const vec3 aabbCenter; // Center of AABB (calculated from LOD D or collider mesh)
	const vec3 aabbSize; // Size of AABB in meters (calculated from LOD D or collider mesh)
	const int index; // 0-based (0 for first car)
	const int gearCount; // Physics-only (see `ac.CarState.physicsAvailable`)
	const int turboCount; // Physics-only (see `ac.CarState.physicsAvailable`)
	const int tractionType; // 0 for rwd, 1 for fwd, 2 for awd, 3 for new awd, -1 for N/A. Physics-only (see `ac.CarState.physicsAvailable`)
	const int enginePosition; // 0 for unspecified, 1 for front, 2 for rear, 3 for mid. Physics-only (see `ac.CarState.physicsAvailable`)
	const float brakesBiasLimitDown; // Physics-only (see `ac.CarState.physicsAvailable`)
	const float brakesBiasLimitUp; // Physics-only (see `ac.CarState.physicsAvailable`)
	const float brakesBiasStep; // Physics-only (see `ac.CarState.physicsAvailable`)
	const int year; // Manufactoring year
	const bool hShifter; // True if car has H-shifter in its physics data
	const bool adjustableTurbo; // Physics-only (see `ac.CarState.physicsAvailable`)
	const bool brakesCockpitBias; // Physics-only (see `ac.CarState.physicsAvailable`)
	const bool extrapolatedMovement; // If set to false and you’re adding objects moving close to cars, use ac.CarState.timestamp to estimate dt in such a way that it would match car physics time
	const bool extendedPhysics; // True if extended car physics is active
	const bool isRacingCar; // True for racing cars (cars with class different from “road” or “street”)
	const bool isRallyCar; // Car counts as rally car if it has a corresponding tag or “rally” in its name
	const bool isOpenWheeler; // Check is based on car tags
	const bool isEngineDiesel; // Check is based on car tags
	const bool isKunosCar; // True if car is standard, from Kunos
	const bool prefersImperialUnits; // True for cars from UK or USA
	const int tractionControlModes; // 0 if TC is not present. Physics-only (see `ac.CarState.physicsAvailable`)
	const int absModes; // 0 if TC is not present. Physics-only (see `ac.CarState.physicsAvailable`)
	const double timestamp; // time of last physics state record, in milliseconds (counting from the same point as ac.SimState.time)
	const mat4x4 transform; // car physics transformation in world space (does not match body transformation! for it, use `bodyTransform`)
	const mat4x4 pitTransform; // transformation of pit position
	const mat4x4 bodyTransform; // car visual transformation (the one applied to 3D model)
	const mat4x4 worldToLocal; // inverse of car visual transformation
	const vec3 pos; // @hidden
	const vec3 position; // car position in the world (corresponds to 0 coordinate in its model space)
	const vec3 velocity; // car velocity in m/s
	const vec3 acceleration; // G-forces, X for sideways relative to car, Z for forwards/backwards.
	const vec3 angularVelocity;
	const vec3 localAngularVelocity;
	const vec3 localVelocity;
	const vec3 up; // vector facing upwards (normalized)
	const vec3 look; // vector facing forward (normalized)
	const vec3 side; // vector facing sideways (normalized)
	const vec3 driverEyesPosition; // in-car coordinates for driver eyes position (can be changed by user)
	const float gas; // throttle, from 0 to 1
	const float brake; // brake, from 0 to 1
	const float clutch; // clutch, from 0 to 1 (1 for pedal fully depressed)
	const float steer; // angle of steering wheel in degrees
	const float handbrake; // handbrake, from 0 to 1
	const int gear; // current gear, 0 for neutral, -1 for reverse. Does not go through 0 on sequential shifts
	const int engagedGear; // current gear, 0 for neutral, -1 for reverse. Goes through 0 on sequential shifts
	const float fuel; // remaining fuel in liters
	const float rpm; // engine RPM
	const float rpmLimiter; // RPM limiter threshold, if exists
	const float speedKmh; // current speed in km/h
	const float turboBoost; // turbo boost value, from 0 and upwards
	const float drivetrainSpeed; // speed delivered to wheels
	const float waterTemperature; // approximation of water temperature in °C done by original AC
	const float minHeight; // minimum allowed ride height in meters
	const float restrictor; // restrictor 
	const float ballast; // ballast in kg 
	const float cgHeight;
	const int wheelsOutside; // number of wheels outside of allowed area
	const float engineLifeLeft; // engine life left (1000 for new engine, breaks at 0)
	const float damage[5]; // damage values from 0 to maximum collision speed in km/h for four different zones (fifth one is not really used)
	const float gearboxDamage; // gearbox damage (0 for new gearbox, 1 for non-functional)
	const int nodeIndex; // car index if 0 is nearest to camera, 1 is second nearest and so on
	const int visibleIndex; // car index if 0 is nearest to camera and visible in main camera, 1 is second nearest visible and so on. Cars outside of main camera would have 255 here.
	const int activeLOD; // 0-based index of visible LOD
	const float distanceToCamera; // distance to camera in meters
	const float splinePosition; // position of car along the track, 0 for starting line, 1 for finishing line
	const float driftPoints; // drift points (calculated in any racing mode)
	const float driftInstantPoints; // drift instant points (calculated in any racing mode)
	const int driftComboCounter; // drift combo counter (calculated in any racing mode)
	const float collisionDepth; // how deep is current collision, in meters (generally it’s better to use change of car speed to estimate collision intensity though, depth is much less predictable)
	const vec3 collisionPosition; // coordinates of current collision in car space
	const int collidedWith; // 0 for track, non-zero for cars
	const int lapCutsCount; // Number of lap cuts in current lap. Physics-only (see `ac.CarState.physicsAvailable`)
	const int lastLapCutsCount; // Number of lap cuts in last lap
	const float aiLevel; // AI level from 0 to 1 (or -1 if there is no AI)
	const float aiAggression; // AI aggression from 0 to 1 (or -1 if there is no AI)
	const lua_vector_int currentSplits; // Time for different splits of current lap, in milliseconds
	const lua_vector_int lastSplits; // Time for different splits of last lap, in milliseconds
	const lua_vector_int bestSplits; // Best splits times (and not splits of best lap), in milliseconds
	const lua_vector_int bestLapSplits; // Splits times of best lap (not necessarily best split times in itself), in milliseconds
	const state_wheel wheels[4];
	const bool isActive; // True if car is currently active (changes to `false` for disconnected cars if server does not have them visible)
	const bool isConnected; // True if car is currently connected (cars can be disconnected online), or if car is not a remote one
	const bool isRemote; // True if car is controlled by another player online
	const bool isAIControlled; // True if car is controlled by AI (or that autopilot thing)
	const bool isLapValid; // True if current lap is valid. Physics-only (see `ac.CarState.physicsAvailable`)
	const bool isLastLapValid; // True if last lap is valid
	const bool isCameraOnBoard; // True if camera is inside this car
	const bool isInPitlane; // True if car is in pits area
	const bool isInPit; // True if car is parked in its pit stop place
	const bool isRetired;
	const bool isEngineLimiterOn;
	const bool isGearGrinding;
	const bool gearGrinding; // @hidden
	const bool headlightsActive;
	const bool brakeLightsActive;
	const bool flashingLightsActive;
	const bool hornActive;
	const bool focused;
	const bool focusedOnInterior;
	const bool isHidingLabels; // if you’re drawing a map, don’t show cars with this flag on (those would be inactive cars or, for example, cars acting like traffic). Flag can change during the race
	const bool isDriftBonusOn; // drift bonus flag (calculated in any racing mode)
	const bool isDriftValid; // is drift valid (calculated in any racing mode)
	const bool isRaceFinished; // car has finished the race
	const bool hazardLights;
	const bool turningLeftLights;
	const bool turningRightLights;
	const bool turningLeftOnly;
	const bool turningRightOnly;
	const bool lowBeams;
	const bool extraA;
	const bool extraB;
	const bool extraC;
	const bool extraD;
	const bool extraE;
	const bool extraF;
	const bool kersCharging;
	const bool turningLightsActivePhase;
	const rgb headlightsColor;
	const float kersCharge;
	const float kersInput;
	const float kersCurrentKJ;
	const float kersMaxKJ;
	const float kersLoad;
	const float distanceDrivenTotalKm;
	const float distanceDrivenSessionKm;
	const float poweredWheelsSpeed;
	const float batteryVoltage;
	const float oilPressure;
	const float oilTemperature;
	const float exhaustTemperature;
	const int wiperModes; // Number of wiper modes, no less than 1 (wipers disabled state counts like a 0th mode, all cars would have that)
	const int wiperMode;
	const float wiperSpeed;
	const float wiperProgress;
	const float bodyWetness; // How wet is car exterior, approximation from 0 to 1 (actual wetness is in 2D map)
	const float compass; // Angle of where car is heading, from 0 to 360 (0/360 for north, 90 for east, etc.)
	const int lapTimeMs; // Time of current lap in milliseconds
	const int bestLapTimeMs; // Time of best lap of this session in milliseconds
	const int previousLapTimeMs; // Time of last lap in milliseconds
	const int lapCount; // Number of completed laps in this session, including spoiled laps
	const int currentSector; // 0-based index of current track split
	const int previousSectorTime; // Time of previous split in milliseconds, or 0 if it’s a first split
	const int racePosition; // Position of a car in the race, 1 for first, 2 for second, etc.
	const int estimatedLapTimeMs; // Based on best lap and performance meter (delta of this lap time vs best lap time)
	const float performanceMeter; // Performance meter comparing this lap with best, seconds
	const float performanceMeterSpeedDifferenceMs; // In AC performance app, there is that red/green bar, it shows this value
	const int sessionLapCount;
	const int compoundIndex; // Index of currently selected tyre compounds
	const int sessionID; // Index of a car in an online race (differs from regular car index: sessionID is an index in entry list, but car.index of your car is always zero)
	const bool physicsAvailable; // cars in replays, or remote cars online do not have regular physics component running, so some data will be missing. Such fields are marked as physics-only in comments.
	const bool speedLimiterInAction; // Physics-only (see `ac.CarState.physicsAvailable`)
	const bool absInAction; // Physics-only (see `ac.CarState.physicsAvailable`)
	const bool tractionControlInAction; // Physics-only (see `ac.CarState.physicsAvailable`)
	const bool hasUserBrakeBias; // Physics-only (see `ac.CarState.physicsAvailable`)
	const bool hasEngineBrakeSettings;
	const bool hasCockpitMGUHMode;
	const bool hasCockpitERSDelivery;
	const bool hasCockpitERSRecovery;
	const bool drsPresent; // Physics-only (see `ac.CarState.physicsAvailable`)
	const bool drsAvailable; // Physics-only (see `ac.CarState.physicsAvailable`)
	const bool drsActive; // Physics-only (see `ac.CarState.physicsAvailable`)
	const bool kersPresent; // Physics-only (see `ac.CarState.physicsAvailable`)
	const bool kersHasButtonOverride; // Physics-only (see `ac.CarState.physicsAvailable`)
	const bool kersButtonPressed; // Physics-only (see `ac.CarState.physicsAvailable`)
	const bool mguhChargingBatteries;
	const bool manualPitsSpeedLimiterEnabled; // Returns `true` if manual pits speed limiter is currently active. Physics-only (see `ac.CarState.physicsAvailable`)            
	const bool userSpeedLimiterEnabled; // Returns `true` if custom physics speed limiter is currently active. Not the same as pit limiter (or manually operated speed limiter). Physics-only (see `ac.CarState.physicsAvailable`)            
	const int mgukDelivery; // starts with 0
	const int mgukDeliveryCount;
	const int mgukRecovery; // from 0 to 10 (for 100%)
	const int tractionControlMode; // 0 for disabled TC. Physics-only (see `ac.CarState.physicsAvailable`)
	const int absMode; // 0 for disabled ABS. Physics-only (see `ac.CarState.physicsAvailable`)
	const int brakeSettingsCount; // @hidden
	const int engineBrakeSettingsCount;
	const int currentEngineBrakeSetting;
	const float fuelPerLap; // Uses original AC fuel estimation. Zero until value is available. Physics-only (see `ac.CarState.physicsAvailable`)                
	const float differentialPreload; // Physics-only (see `ac.CarState.physicsAvailable`)
	const float awdFrontShare; // Physics-only (see `ac.CarState.physicsAvailable`)
	const float awdCenterLock; // Physics-only (see `ac.CarState.physicsAvailable`)
	const float drivetrainTorque; // Physics-only (see `ac.CarState.physicsAvailable`)
	const float drivetrainPower; // Physics-only (see `ac.CarState.physicsAvailable`)
	const float brakeBias; // Physics-only (see `ac.CarState.physicsAvailable`)
	const float speedLimiter; // Returns pit limiter speed in km/h (80 by default unless session specified different settings) or 0 if no limit is currently active. Physics-only (see `ac.CarState.physicsAvailable`)            
	const float turboBoosts[8]; // Values per each turbo, up to 8 (if there are less turbos in a car, rest are zeroes). Physics-only (see `ac.CarState.physicsAvailable`)
	const float turboWastegates[8]; // Values per each turbo, up to 8 (if there are less turbos in a car, rest are zeroes). Physics-only (see `ac.CarState.physicsAvailable`)
	const float tractionControl2;
	const float fuelMap; // Current fuel map preset
	const float steerTorque;
	const float ffbFinal;
	const float ffbPure;
	const float finalForceFeedback; // @hidden
	const float ffbMultiplier; // for 100% FFB multiplier, this value is set to 1
	const float aeroLiftFront; // Aero lift coefficient in front
	const float aeroLiftRear; // Aero lift coefficient in rear
	const float aeroDrag; // Aero drag coefficient
	const float caster; // caster angle in degrees
	const float rideHeight[2]; // 0 for front, 1 for rear
	const int p2pStatus;
	const int p2pActivations;
	const float altitude; // Altitude in meters above sea level.
	const float ambientOcclusion; // Ambient occlusion value computed from prebaked data from track’s VAO patch. 0 for car fully shadowed (in a tunnel), 1 for car outside.
	const int carCamerasCount; // Number of F6 cameras.
	const int currentPenaltyType; // Current penalty type (set only for user car).
	const int currentPenaltyParameter; // Parameter of current penalty (role depends on penalty type).
}

struct ac.StateSession {
	const int type;
	const int laps;
	const float durationMinutes;
	const bool isTimedRace;
	const bool hasAdditionalLap;
	const double startTime; // Starting time in milliseconds (compares with `ac.SimState.time`)
	const float overtimeMs;
	const int forcedPosition;
	const int leaderCompletedLaps;
	const bool isOver;
}

struct ac.StateWheelPhysics {
	const float brakeTorque;
	const float handbrakeTorque;
	const float electricTorque;
	const float feedbackTorque;
	const float angularInertia;
	const float shaftVelocity;
	const float shaftInertia;
}

struct ac.StateCarPhysics {
	const int _inner; // @hidden
	const bool isAvailable;
	const float gearRatio;
	const float finalRatio;
	const float awd2MaxTorque;
	const float awd2CurrentLockTorque;
	const float awd2Ramp;
	const float engineInertia;
	const float drivetrainInertia;
	const float drivetrainVelocity;
	const float clutchInertia;
	const float clutchState;
	const state_wheel_physics wheels[4];
	const float scriptControllerInputs[8];
}

struct ac.StateSim {
	const int windowWidth; // width of AC window in pixels (set in AC video settings). Might not be the same as UI screen size if scaling is used.
	const int windowHeight; // height of AC window in pixels (set in AC video settings). Might not be the same as UI screen size if scaling is used.
	const int msaaSamples; // 1 for MSAA disabled, 2 for MSAA 2x, 4 for 4x, 8 for 8x
	const int worldDetailLevel; // 0 for very low, 5 for very high. Set in AC video settings
	const bool isFullscreen; // A value from AC video settings, does not change live
	const bool isVSyncActive; // A value from AC video settings, does not change live
	const bool isPostProcessingActive; // True if YEBIS post-processing is active
	const bool isVRMode; // True if AC was launched with either Oculus or OpenVR mode (not necessarily successfully connected)
	const bool isOculusMode; // True if AC was launched with Oculus mode (not necessarily successfully connected)
	const bool isOpenVRMode; // True if AC was launched with OpenVR mode (not necessarily successfully connected)
	const bool isTripleMode; // True if AC was launched in triple screen mode
	const bool isCustomVideMode; // @hidden
	const bool isCustomVideoMode; // True if AC was launched with custom screen mode (fisheye, 360°, splitscreen)
	const bool isVRConnected; // True if AC runs in either Oculus or OpenVR mode and initialization went successfully
	const bool staticReflections; // True if reflection cubemap does not update live and uses custom cubemap.kn5 instead of track model
	const bool directMessagingAvailable; // True if it’s an online race and server supports TCP exchange of extra data between clients (allows to send online events more frequently)
	const double time; // game time in milliseconds (counting from the start of the simulation)
	const vec3 cameraPosition;
	const vec3 cameraLook; // points forward (there was some confusion with older API)
	const vec3 cameraUp;
	const vec3 cameraSide;
	const float cameraFOV; // returns current camera FOV in degrees. In VR, always returns 90°
	const float cameraClipNear; // distance to near clipping plane in meters
	const float cameraClipFar; // distance to far clipping plane in meters
	const float cameraDOFFactor;
	const float cameraDOFFocus;
	const int carsCount; // no less than 1: at least a single car would always be present
	const int closelyFocusedCar; // 0-based index, or -1 if there is no focused car (for example, with track camera or with free camera far from other cars)
	const int focusedCar; // 0-based index, or -1 if there is no focused car, unlike `.closelyFocusedCar` returns index of a car with track camera as well
	const float dt; // Delta time in seconds, 0 when paused, affected by replay slow motion and fast forwarding
	const bool isPaused; // If `true`, AC is currently paused
	const bool isInMainMenu; // If `true`, main menu is currently active
	const bool isLive; // If `true`, simulation is currently running (not paused and not in replay mode)
	const bool isFreeCameraOutside; // Set to `true` if camera is either free or orbit (F7/F5) and not inside an interior 
	const bool isReplayActive;
	const bool isReplayOnlyMode; // True if AC is ran in replay mode, without any racing
	const bool isOnlineRace; // True if it’s an online race
	const bool isFocusedOnInterior; // True if camera is currently inside a car 
	const bool controlsWithShifter;
	const bool isVirtualMirrorActive;
	const bool virtualMirrorActive; // @hidden
	const bool isVirtualMirrorForced;
	const bool isWindowForeground; // True if AC window is currently active (focused and in front of other windows)
	const bool isWeatherFXActive;
	const bool isVAOPatchLoaded;
	const float ambientLightingMultiplier;
	const float ambientTemperature;
	const float roadTemperature;
	const float windSpeedKmh;
	const vec2 windVelocityKmh;
	const float windDirectionDeg;
	const float rainIntensity;
	const float rainWetness;
	const float rainWater;
	const float timeTotalSeconds; // Number of seconds from midnight, not rounded
	const int timeHours; // Number of hours from midnight, rounded down
	const int timeMinutes; // Number of minutes in current hour, rounded down
	const int timeSeconds; // Number of seconds in current minute, rounded down
	const float timeMultiplier; // Time multiplier set in race conditions
	const int timestamp; // Timestamp for in-game time (whole number seconds since 01/01/1970)
	const int dayOfYear; // Returns number of current day in the year, from 1 to 366
	const int raceFlagType;
	const bool isSessionStarted;
	const int raceSessionType;
	const double timeToSessionStart; // Time to session start in milliseconds
	const double sessionTimeLeft; // Remaining session time in milliseconds
	const int currentSessionIndex; // 0-based index of current session (`.sessions` store more details about each session)
	const int sessionsCount;
	const float trackLengthM;
	const float speedLimitKmh;
	const float fps;
	const float fpsCapped;
	const float physicsLate;
	const int cpuOccupancy;
	const float cpuTime;
	const float onboardCameraFOV; // @hidden
	const float firstPersonCameraFOV; // Current value for first person camera FOV in degrees. Global value, applying for all cars.
	const int cameraMode;
	const int driveableCameraMode;
	const int carCameraIndex; // 0-based index of currently active car camera (if `.cameraMode` is set to `ac.CameraMode.Car`). To find out how many ofd those cameras there are, use `ac.getCar(sim.focusedCar).carCamerasCount`
	const int trackCamerasSetsCount;
	const int trackCamerasSet; // 0-based index of currently active track cameras set
	const float audioMasterVolume;
	const float whiteReferencePoint; // Brightness of objects that would look white on-screen, such as UI in VR or driver name tags. You can also use it as a divider to adjust brightness of virtual mirrors (if you are not using postprocessing for virtual mirrors).
	const bool specialEvent; // One of those archievment challenges is active
	const bool isTimedRace;
	const bool penaltiesEnabled;
	const bool fixedSetup;
	const bool leaderLastLap;
	const bool timeRaceEnded;
	const bool timeRaceLastLap;
	const bool timeRaceAdditionalLap;
	const bool isAdmin; // Changes to true if user signs up as admin using that new chat app
	const float pitsSpeedLimit; // Maximum speed allowed in pits in km/h. Regular value is 80, but servers might change it
	const float pitWindowStartTime; // If non-zero, start of mandatory pit time window (to get current time, use `.time`)
	const float pitWindowEndTime; // If non-zero, end of mandatory pit time window (to get current time, use `.time`)
	const float replayFrameMs; // Time of each replay frame in milliseconds
	const int replayFrames; // Number of recorded replay frames
	const int replayCurrentFrame; // 0-based index of current replay frame
	const float replayPlaybackRate; // 0-based index of current replay frame
	const char weatherType; // Current weather type, set by WeatherFX controller or guessed from weather name
	const float weatherSkyOcclusion; // Estimates sky occlusion based on current weather type
	const float baseAltitude; // Altitude in meters above sea level associated with Y=0 level.
	const int connectedCars; // Number of currently connected cars
	const int randomSeed; // Synced between clients online
	const lua_vector_float lapSplits; // Normalized positions of track splits
	const double handshakeServerTime; // Server time of the handshake, in milliseconds
	const double currentServerTime; // Current server time (synced on all clients), in milliseconds. Resets to 0 when new race session (P/Q/R) starts.
	const rgb skyColor; // Sky color
	const rgb horizonColor; // Horizon color
	const rgb fogColor; // Fog color
	const rgb lightColor; // Light (sun or moon) color
	const vec3 lightDirection; // Light (sun or moon) direction
}

struct ac.StateUi {
	const vec2 windowSize; // Size of AC UI window (affected by UI scale)
	const vec2 mousePos; // Mouse position within an AC UI window (affected by UI scale)
	const float dt; // Time between frames in seconds (not affected by pausing or replay speed modifier)
	const float mouseWheel; // Mouse wheel Vertical: 1 unit scrolls about 5 lines text.
	const bool isMouseLeftKeyClicked; // Left mouse button was just pressed
	const bool isMouseMiddleKeyClicked; // Middle mouse button was just pressed
	const bool isMouseRightKeyClicked; // Right mouse button was just pressed
	const bool isMouseLeftKeyDoubleClicked; // Left mouse button was just double clicked
	const bool isMouseMiddleKeyDoubleClicked; // Middle mouse button was just double clicked
	const bool isMouseRightKeyDoubleClicked; // Right mouse button was just double clicked
	const bool isMouseLeftKeyDown; // Left mouse button is currently held
	const bool isMouseMiddleKeyDown; // Middle mouse button is currently held
	const bool isMouseRightKeyDown; // Right mouse button is currently held
	const bool ctrlDown; // Keyboard modifier pressed: Control
	const bool shiftDown; // Keyboard modifier pressed: Shift
	const bool altDown; // Keyboard modifier pressed: Alt
	const bool superDown; // Keyboard modifier pressed: Cmd/Super/Windows
	const bool wantCaptureMouse; // If your script is listening to mouse events, you might need to disable this functionality if this value is `true` — it means mouse is currently captured by some IMGUI element (for example, dragging happens).
	const bool wantCaptureKeyboard; // If your script is listening to keyboard events, you might need to disable this functionality if this value is `true` — it means keyboard is currently captured by some IMGUI element (for example, user enters text in a text box).
	const bool vrController; // If true, mouse is currenly controlled by VR controller, so its precision might be lower
	const float framerate; // UI framerate estimation, in frame per second. Solely for convenience. Rolling average estimation based on IO.DeltaTime over 120 frames
	const int metricsRenderVertices; // Vertices output during last call to Render()
	const int metricsRenderIndices; // Indices output during last call to Render() = number of triangles * 3
	const int metricsRenderWindows; // Number of visible windows
	const int metricsActiveWindows; // Number of active windows
	const int metricsRenderCommands; // Number of draw calls
	const vec2 mouseDelta; // Mouse delta. Note that this is zero if either current or previous position are invalid (-FLT_MAX,-FLT_MAX), so a disappearing/reappearing mouse won't have a huge delta.
	const float uiScale; // UI scale. Usually scripts shouldn’t worry about it, but just in case
	const rgbm accentColor; // Theme-defined accent color
}

struct ac.StateVrHand {
	const mat4x4 transform;
	const float triggerIndex;
	const float triggerHand;
	const vec2 thumbstick;
	const bool active;
	const bool thumbUp;
	const bool indexPointing;
	const bool busy; // Set to true if hand is already going something, like grabbing an object. If so, don’t do any more grabbing (and don’t forget to call `ac.setVRHandBusy()` when you do)
	const uint64_t openVRButtons; // OpenVR-specific buttons
	const uint64_t openVRTouches; // OpenVR-specific touches
	const vec2 openVRAxis[5]; // OpenVR-specific touches
}

struct ac.StateVr {
	const mat4x4 headTransform;
	const bool headActive;
	const int oculusButtons; // Oculus-specific buttons
	const int oculusTouches; // Oculus-specific touches
	const int activeHand; // index of a hand that is actively moving, or -1
	const state_vr_hand hands[2];
}

struct ac.StateDualsenseTouch {
	const vec2 delta;
	const vec2 pos;
	const int id;
	const bool down;
}

struct ac.StateDualsense {
	const vec3 accelerometer;
	const vec3 gyroscope;
	const float battery;
	const state_dualsense_touch touches[2];
	const bool batteryCharging;
	const bool batteryFullyCharged;
	const bool headphonesConnected;
	const bool connected;
}

struct ac.StateDualsenseOutput {
	rgbm lightBar;
	int microphoneLED; // 0 for disabled, 1 for enabled, 2 for flashing
	int playerLEDsBrightness; // 0 for max, 1 for medium, 2 for low
	bool disableLEDs;
	bool playerLEDsFade;
	bool playerLEDs[5];
}